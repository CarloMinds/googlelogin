"use strict"; Janus.sessions = new Map, Janus.isExtensionEnabled = function () { if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) return !0; if (window.navigator.userAgent.match("Chrome")) { let e = parseInt(window.navigator.userAgent.match(/Chrome\/(.*) /)[1], 10), n = 33; return window.navigator.userAgent.match("Linux") && (n = 35), e >= 26 && e <= n || Janus.extension.isInstalled() } return !0 }; var defaultExtension = { extensionId: "hapfgfdkleiggjjpfpenajgdnfckjpaj", isInstalled: function () { return null !== document.querySelector("#janus-extension-installed") }, getScreen: function (e) { let n = window.setTimeout((function () { let n = new Error("NavigatorUserMediaError"); return n.name = 'The required Chrome extension is not installed: click <a href="#">here</a> to install it. (NOTE: this will need you to refresh the page)', e(n) }), 1e3); this.cache[n] = e, window.postMessage({ type: "janusGetScreen", id: n }, "*") }, init: function () { let e = {}; this.cache = e, window.addEventListener("message", (function (n) { if (n.origin == window.location.origin) if ("janusGotScreen" == n.data.type && e[n.data.id]) { let r = e[n.data.id]; if (delete e[n.data.id], "" === n.data.sourceId) { let e = new Error("NavigatorUserMediaError"); e.name = "You cancelled the request for permission, giving up...", r(e) } else r(null, n.data.sourceId) } else "janusGetScreenPending" == n.data.type && (console.log("clearing ", n.data.id), window.clearTimeout(n.data.id)) })) } }; function Janus(e) { if ((e = e || {}).success = "function" == typeof e.success ? e.success : Janus.noop, e.error = "function" == typeof e.error ? e.error : Janus.noop, e.destroyed = "function" == typeof e.destroyed ? e.destroyed : Janus.noop, !Janus.initDone) return e.error("Library not initialized"), {}; if (!Janus.isWebrtcSupported()) return e.error("WebRTC not supported by this browser"), {}; if (Janus.log("Library initialized: " + Janus.initDone), !e.server) return e.error("Invalid server url"), {}; let n = !1, r = null, t = {}, a = null, o = null, s = 0, i = e.server; Janus.isArray(i) ? (Janus.log("Multiple servers provided (" + i.length + "), will use the first that works"), i = null, o = e.server, Janus.debug(o)) : 0 === i.indexOf("ws") ? (n = !0, Janus.log("Using WebSockets to contact Janus: " + i)) : (n = !1, Janus.log("Using REST API to contact Janus: " + i)); let c = e.iceServers || [{ urls: "stun:stun.l.google.com:19302" }], d = e.iceTransportPolicy, u = e.bundlePolicy, l = !1; void 0 !== e.withCredentials && null !== e.withCredentials && (l = !0 === e.withCredentials); let f = 10; void 0 !== e.max_poll_events && null !== e.max_poll_events && (f = e.max_poll_events), f < 1 && (f = 1); let p = null; void 0 !== e.token && null !== e.token && (p = e.token); let g = null; void 0 !== e.apisecret && null !== e.apisecret && (g = e.apisecret), this.destroyOnUnload = !0, void 0 !== e.destroyOnUnload && null !== e.destroyOnUnload && (this.destroyOnUnload = !0 === e.destroyOnUnload); let m = 25e3; void 0 !== e.keepAlivePeriod && null !== e.keepAlivePeriod && (m = e.keepAlivePeriod), isNaN(m) && (m = 25e3); let v = 6e4; function J(e) { let n = { high: 9e5, medium: 3e5, low: 1e5 }; return null != e && (e.high && (n.high = e.high), e.medium && (n.medium = e.medium), e.low && (n.low = e.low)), n } void 0 !== e.longPollTimeout && null !== e.longPollTimeout && (v = e.longPollTimeout), isNaN(v) && (v = 6e4); let h = !1, b = null, w = new Map, y = this, S = 0, k = new Map; function T() { if (null == b) return; if (Janus.debug("Long poll..."), !h) return void Janus.warn("Is the server down? (connected=false)"); let n = i + "/" + b + "?rid=" + (new Date).getTime(); f && (n = n + "&maxev=" + f), p && (n = n + "&token=" + encodeURIComponent(p)), g && (n = n + "&apisecret=" + encodeURIComponent(g)), Janus.httpAPICall(n, { verb: "GET", withCredentials: l, success: C, timeout: v, error: function (n, r) { if (Janus.error(n + ":", r), S++, S > 3) return h = !1, void e.error("Lost connection to the server (is it down?)"); T() } }) } function C(e, t) { if (S = 0, n || null == b || !0 === t || T(), n || !Janus.isArray(e)) if ("keepalive" !== e.janus) if ("server_info" !== e.janus) if ("ack" !== e.janus) if ("success" !== e.janus) if ("trickle" === e.janus) { const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); const r = w.get(n); if (!r) return void Janus.debug("This handle is not attached to this session"); let t = e.candidate; Janus.debug("Got a trickled candidate on session " + b), Janus.debug(t); let a = r.webrtcStuff; a.pc && a.remoteSdp ? (Janus.debug("Adding remote candidate:", t), t && !0 !== t.completed ? a.pc.addIceCandidate(t) : a.pc.addIceCandidate(Janus.endOfCandidates)) : (Janus.debug("We didn't do setRemoteDescription (trickle got here before the offer?), caching candidate"), a.candidates || (a.candidates = []), a.candidates.push(t), Janus.debug(a.candidates)) } else { if ("webrtcup" === e.janus) { Janus.debug("Got a webrtcup event on session " + b), Janus.debug(e); const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); const r = w.get(n); return r ? void r.webrtcState(!0) : void Janus.debug("This handle is not attached to this session") } if ("hangup" === e.janus) { Janus.debug("Got a hangup event on session " + b), Janus.debug(e); const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); const r = w.get(n); if (!r) return void Janus.debug("This handle is not attached to this session"); r.webrtcState(!1, e.reason), r.hangup() } else if ("detached" === e.janus) { Janus.debug("Got a detached event on session " + b), Janus.debug(e); const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); const r = w.get(n); if (!r) return; r.ondetached(), r.detach() } else if ("media" === e.janus) { Janus.debug("Got a media event on session " + b), Janus.debug(e); const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); const r = w.get(n); if (!r) return void Janus.debug("This handle is not attached to this session"); r.mediaState(e.type, e.receiving, e.mid) } else if ("slowlink" === e.janus) { Janus.debug("Got a slowlink event on session " + b), Janus.debug(e); const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); const r = w.get(n); if (!r) return void Janus.debug("This handle is not attached to this session"); r.slowLink(e.uplink, e.lost, e.mid) } else { if ("error" === e.janus) { Janus.error("Ooops: " + e.error.code + " " + e.error.reason), Janus.debug(e); let n = e.transaction; if (n) { let r = k.get(n); r && r(e), k.delete(n) } return } if ("event" === e.janus) { Janus.debug("Got a plugin event on session " + b), Janus.debug(e); const n = e.sender; if (!n) return void Janus.warn("Missing sender..."); let r = e.plugindata; if (!r) return void Janus.warn("Missing plugindata..."); Janus.debug("  -- Event is coming from " + n + " (" + r.plugin + ")"); let t = r.data; Janus.debug(t); const a = w.get(n); if (!a) return void Janus.warn("This handle is not attached to this session"); let o = e.jsep; o && (Janus.debug("Handling SDP as well..."), Janus.debug(o)); let s = a.onmessage; s ? (Janus.debug("Notifying application..."), s(t, o)) : Janus.debug("No provided notification callback") } else { if ("timeout" === e.janus) return Janus.error("Timeout on session " + b), Janus.debug(e), void (n && r.close(3504, "Gateway timeout")); Janus.warn("Unknown message/event  '" + e.janus + "' on session " + b), Janus.debug(e) } } } else { Janus.debug("Got a success on session " + b), Janus.debug(e); const n = e.transaction; if (n) { const r = k.get(n); r && r(e), k.delete(n) } } else { Janus.debug("Got an ack on session " + b), Janus.debug(e); const n = e.transaction; if (n) { const r = k.get(n); r && r(e), k.delete(n) } } else { Janus.debug("Got info on the Janus instance"), Janus.debug(e); const n = e.transaction; if (n) { const r = k.get(n); r && r(e), k.delete(n) } } else Janus.vdebug("Got a keepalive on session " + b); else for (let n = 0; n < e.length; n++)C(e[n], !0) } function I() { if (!i || !n || !h) return; a = setTimeout(I, m); let e = { janus: "keepalive", session_id: b, transaction: Janus.randomString(12) }; p && (e.token = p), g && (e.apisecret = g), r.send(JSON.stringify(e)) } function R(c) { let d = Janus.randomString(12), u = { janus: "create", transaction: d }; if (c.reconnect && (h = !1, u.janus = "claim", u.session_id = b, r && (r.onopen = null, r.onerror = null, r.onclose = null, a && (clearTimeout(a), a = null))), p && (u.token = p), g && (u.apisecret = g), !i && Janus.isArray(o) && (i = o[s], 0 === i.indexOf("ws") ? (n = !0, Janus.log("Server #" + (s + 1) + ": trying WebSockets to contact Janus (" + i + ")")) : (n = !1, Janus.log("Server #" + (s + 1) + ": trying REST API to contact Janus (" + i + ")"))), n) { r = Janus.newWebSocket(i, "janus-protocol"), t = { error: function () { if (Janus.error("Error connecting to the Janus WebSockets server... " + i), Janus.isArray(o) && !c.reconnect) return s++, s === o.length ? void c.error("Error connecting to any of the provided Janus servers: Is the server down?") : (i = null, void setTimeout((function () { R(c) }), 200)); c.error("Error connecting to the Janus WebSockets server: Is the server down?") }, open: function () { k.set(d, (function (e) { if (Janus.debug(e), "success" !== e.janus) return Janus.error("Ooops: " + e.error.code + " " + e.error.reason), void c.error(e.error.reason); a = setTimeout(I, m), h = !0, b = e.session_id ? e.session_id : e.data.id, c.reconnect ? Janus.log("Claimed session: " + b) : Janus.log("Created session: " + b), Janus.sessions.set(b, y), c.success() })), r.send(JSON.stringify(u)) }, message: function (e) { C(JSON.parse(e.data)) }, close: function () { i && h && (h = !1, e.error("Lost connection to the server (is it down?)")) } }; for (let e in t) r.addEventListener(e, t[e]) } else Janus.httpAPICall(i, { verb: "POST", withCredentials: l, body: u, success: function (e) { if (Janus.debug(e), "success" !== e.janus) return Janus.error("Ooops: " + e.error.code + " " + e.error.reason), void c.error(e.error.reason); h = !0, b = e.session_id ? e.session_id : e.data.id, c.reconnect ? Janus.log("Claimed session: " + b) : Janus.log("Created session: " + b), Janus.sessions.set(b, y), T(), c.success() }, error: function (e, n) { if (Janus.error(e + ":", n), Janus.isArray(o) && !c.reconnect) return s++, s === o.length ? void c.error("Error connecting to any of the provided Janus servers: Is the server down?") : (i = null, void setTimeout((function () { R(c) }), 200)); "" === n ? c.error(e + ": Is the server down?") : n && n.error ? c.error(e + ": " + n.error.message) : c.error(e + ": " + n) } }) } function A(e, t) { if ((t = t || {}).success = "function" == typeof t.success ? t.success : Janus.noop, t.error = "function" == typeof t.error ? t.error : Janus.noop, !h) return Janus.warn("Is the server down? (connected=false)"), void t.error("Is the server down? (connected=false)"); let a = w.get(e); if (!a || !a.webrtcStuff) return Janus.warn("Invalid handle"), void t.error("Invalid handle"); let o = t.message, s = t.jsep, c = Janus.randomString(12), d = { janus: "message", body: o, transaction: c }; if (a.token && (d.token = a.token), g && (d.apisecret = g), s) { d.jsep = { type: s.type, sdp: s.sdp }, s.e2ee && (d.jsep.e2ee = !0), "hml" !== s.rid_order && "lmh" !== s.rid_order || (d.jsep.rid_order = s.rid_order), s.force_relay && (d.jsep.force_relay = !0); let e = null, n = a.webrtcStuff; if (n.pc) { let r = n.pc.getTransceivers(); if (r && r.length > 0) for (let n in r) { let t = r[n]; if (t && t.sender && t.sender.track && "video" === t.sender.track.kind) { let r = t.sender.getParameters(); r && r.encodings && r.encodings[0] && r.encodings[0].scalabilityMode && (e || (e = []), e.push({ mindex: parseInt(n), mid: t.mid, svc: r.encodings[0].scalabilityMode })) } } } e && (d.jsep.svc = e) } if (Janus.debug("Sending message to plugin (handle=" + e + "):"), Janus.debug(d), n) return d.session_id = b, d.handle_id = e, k.set(c, (function (e) { if (Janus.debug("Message sent!"), Janus.debug(e), "success" === e.janus) { let n = e.plugindata; if (!n) return Janus.warn("Request succeeded, but missing plugindata..."), void t.success(); Janus.log("Synchronous transaction successful (" + n.plugin + ")"); let r = n.data; return Janus.debug(r), void t.success(r) } "ack" === e.janus ? t.success() : e.error ? (Janus.error("Ooops: " + e.error.code + " " + e.error.reason), t.error(e.error.code + " " + e.error.reason)) : (Janus.error("Unknown error"), t.error("Unknown error")) })), void r.send(JSON.stringify(d)); Janus.httpAPICall(i + "/" + b + "/" + e, { verb: "POST", withCredentials: l, body: d, success: function (e) { if (Janus.debug("Message sent!"), Janus.debug(e), "success" === e.janus) { let n = e.plugindata; if (!n) return Janus.warn("Request succeeded, but missing plugindata..."), void t.success(); Janus.log("Synchronous transaction successful (" + n.plugin + ")"); let r = n.data; return Janus.debug(r), void t.success(r) } "ack" === e.janus ? t.success() : e.error ? (Janus.error("Ooops: " + e.error.code + " " + e.error.reason), t.error(e.error.code + " " + e.error.reason)) : (Janus.error("Unknown error"), t.error("Unknown error")) }, error: function (e, n) { Janus.error(e + ":", n), t.error(e + ": " + n) } }) } function D(e, t) { if (!h) return void Janus.warn("Is the server down? (connected=false)"); let a = w.get(e); if (!a || !a.webrtcStuff) return void Janus.warn("Invalid handle"); let o = { janus: "trickle", candidate: t, transaction: Janus.randomString(12) }; if (a.token && (o.token = a.token), g && (o.apisecret = g), Janus.vdebug("Sending trickle candidate (handle=" + e + "):"), Janus.vdebug(o), n) return o.session_id = b, o.handle_id = e, void r.send(JSON.stringify(o)); Janus.httpAPICall(i + "/" + b + "/" + e, { verb: "POST", withCredentials: l, body: o, success: function (e) { Janus.vdebug("Candidate sent!"), Janus.vdebug(e), "ack" === e.janus || Janus.error("Ooops: " + e.error.code + " " + e.error.reason) }, error: function (e, n) { Janus.error(e + ":", n) } }) } function P(e, n, r, t, a) { let o = w.get(e); if (!o || !o.webrtcStuff) return void Janus.warn("Invalid handle"); let s = o.webrtcStuff; if (!s.pc) return void Janus.warn("Invalid PeerConnection"); let i = function (e) { Janus.log("Received state change on data channel:", e); let n = e.target.label, r = e.target.protocol, t = s.dataChannel[n] ? s.dataChannel[n].readyState : "null"; if (Janus.log("State change on <" + n + "> data channel: " + t), "open" === t) { if (s.dataChannel[n].pending && s.dataChannel[n].pending.length > 0) { Janus.log("Sending pending messages on <" + n + ">:", s.dataChannel[n].pending.length); for (let e of s.dataChannel[n].pending) Janus.log("Sending data on data channel <" + n + ">"), Janus.debug(e), s.dataChannel[n].send(e); s.dataChannel[n].pending = [] } o.ondataopen(n, r) } }; if (t) s.dataChannel[n] = t; else { let e = s.dataChannelOptions; r && (e.protocol = r), s.dataChannel[n] = s.pc.createDataChannel(n, e) } s.dataChannel[n].onmessage = function (e) { Janus.log("Received message on data channel:", e); let n = e.target.label; o.ondata(e.data, n) }, s.dataChannel[n].onopen = i, s.dataChannel[n].onclose = i, s.dataChannel[n].onerror = function (e) { Janus.error("Got error on data channel:", e) }, s.dataChannel[n].pending = [], a && s.dataChannel[n].pending.push(a) } function E(e, n) { (n = n || {}).success = "function" == typeof n.success ? n.success : Janus.noop, n.error = "function" == typeof n.error ? n.error : Janus.noop; let r = w.get(e); if (!r || !r.webrtcStuff) return Janus.warn("Invalid handle"), void n.error("Invalid handle"); let t = r.webrtcStuff, a = n.text || n.data; if (!a) return Janus.warn("Invalid data"), void n.error("Invalid data"); let o = n.label ? n.label : Janus.dataChanDefaultLabel; return t.dataChannel[o] ? "open" !== t.dataChannel[o].readyState ? (t.dataChannel[o].pending.push(a), void n.success()) : (Janus.log("Sending data on data channel <" + o + ">"), Janus.debug(a), t.dataChannel[o].send(a), void n.success()) : (P(e, o, n.protocol, !1, a, n.protocol), void n.success()) } function O(e, n) { (n = n || {}).success = "function" == typeof n.success ? n.success : Janus.noop, n.error = "function" == typeof n.error ? n.error : Janus.noop; let r = w.get(e); if (!r || !r.webrtcStuff) return Janus.warn("Invalid handle"), void n.error("Invalid handle"); let t = r.webrtcStuff; if (!t.dtmfSender) { if (t.pc) { let e = t.pc.getSenders().find((function (e) { return e.track && "audio" === e.track.kind })); if (!e) return Janus.warn("Invalid DTMF configuration (no audio track)"), void n.error("Invalid DTMF configuration (no audio track)"); t.dtmfSender = e.dtmf, t.dtmfSender && (Janus.log("Created DTMF Sender"), t.dtmfSender.ontonechange = function (e) { Janus.debug("Sent DTMF tone: " + e.tone) }) } if (!t.dtmfSender) return Janus.warn("Invalid DTMF configuration"), void n.error("Invalid DTMF configuration") } let a = n.dtmf; if (!a) return Janus.warn("Invalid DTMF parameters"), void n.error("Invalid DTMF parameters"); let o = a.tones; if (!o) return Janus.warn("Invalid DTMF string"), void n.error("Invalid DTMF string"); let s = "number" == typeof a.duration ? a.duration : 500, i = "number" == typeof a.gap ? a.gap : 50; Janus.debug("Sending DTMF string " + o + " (duration " + s + "ms, gap " + i + "ms)"), t.dtmfSender.insertDTMF(o, s, i), n.success() } function j(e, t) { (t = t || {}).success = "function" == typeof t.success ? t.success : Janus.noop, t.error = "function" == typeof t.error ? t.error : Janus.noop; let a = !0 === t.noRequest; Janus.log("Destroying handle " + e + " (only-locally=" + a + ")"), H(e); let o = w.get(e); if (!o || o.detached) return w.delete(e), void t.success(); if (o.detached = !0, a) return w.delete(e), void t.success(); if (!h) return Janus.warn("Is the server down? (connected=false)"), void t.error("Is the server down? (connected=false)"); let s = { janus: "detach", transaction: Janus.randomString(12) }; if (o.token && (s.token = o.token), g && (s.apisecret = g), n) return s.session_id = b, s.handle_id = e, r.send(JSON.stringify(s)), w.delete(e), void t.success(); Janus.httpAPICall(i + "/" + b + "/" + e, { verb: "POST", withCredentials: l, body: s, success: function (n) { Janus.log("Destroyed handle:"), Janus.debug(n), "success" !== n.janus && Janus.error("Ooops: " + n.error.code + " " + n.error.reason), w.delete(e), t.success() }, error: function (n, r) { Janus.error(n + ":", r), w.delete(e), t.success() } }) } function M(e, n) { let r = w.get(e); if (!r || !r.webrtcStuff) throw Janus.warn("Invalid handle"), "Invalid handle"; let t = r.webrtcStuff; if (t.pc) return; let a = { iceServers: c, iceTransportPolicy: d, bundlePolicy: u, sdpSemantics: "unified-plan" }, o = !1; if (n.tracks) for (let e of n.tracks) if (e.transforms && (e.transforms.sender || e.transforms.receiver)) { o = !0; break } RTCRtpSender && (RTCRtpSender.prototype.createEncodedStreams || RTCRtpSender.prototype.createEncodedAudioStreams && RTCRtpSender.prototype.createEncodedVideoStreams) && o && (t.insertableStreams = !0, a.forceEncodedAudioInsertableStreams = !0, a.forceEncodedVideoInsertableStreams = !0, a.encodedInsertableStreams = !0), Janus.log("Creating PeerConnection"), t.pc = new RTCPeerConnection(a), Janus.debug(t.pc), t.pc.getStats && (t.volume = {}, t.bitrate.value = "0 kbits/sec"), Janus.log("Preparing local SDP and gathering candidates (trickle=" + t.trickle + ")"), t.pc.oniceconnectionstatechange = function () { t.pc && r.iceState(t.pc.iceConnectionState) }, t.pc.onicecandidate = function (r) { if (!r.candidate || r.candidate.candidate && r.candidate.candidate.indexOf("endOfCandidates") > 0) Janus.log("End of candidates."), t.iceDone = !0, !0 === t.trickle ? D(e, { completed: !0 }) : function (e, n) { n = n || {}, n.success = "function" == typeof n.success ? n.success : Janus.noop, n.error = "function" == typeof n.error ? n.error : Janus.noop; let r = w.get(e); if (!r || !r.webrtcStuff) return void Janus.warn("Invalid handle, not sending anything"); let t = r.webrtcStuff; if (Janus.log("Sending offer/answer SDP..."), !t.mySdp) return void Janus.warn("Local SDP instance is invalid, not sending anything..."); t.mySdp = { type: t.pc.localDescription.type, sdp: t.pc.localDescription.sdp }, !1 === t.trickle && (t.mySdp.trickle = !1); Janus.debug(n), t.sdpSent = !0, n.success(t.mySdp) }(e, n); else { let n = { candidate: r.candidate.candidate, sdpMid: r.candidate.sdpMid, sdpMLineIndex: r.candidate.sdpMLineIndex }; !0 === t.trickle && D(e, n) } }, t.pc.ontrack = function (e) { if (Janus.log("Handling Remote Track", e), !e.streams) return; if (!e.track) return; let n = e.transceiver ? e.transceiver.mid : e.track.id; try { r.onremotetrack(e.track, n, !0, { reason: "created" }) } catch (e) { Janus.error("Error calling onremotetrack", e) } if (e.track.onended) return; let a = null; Janus.log("Adding onended callback to track:", e.track), e.track.onended = function (e) { Janus.log("Remote track removed:", e), clearTimeout(a); let n = t.pc ? t.pc.getTransceivers() : null, o = n ? n.find((n => n.receiver.track === e.target)) : null, s = o ? o.mid : e.target.id; try { r.onremotetrack(e.target, s, !1, { reason: "ended" }) } catch (e) { Janus.error("Error calling onremotetrack on removal", e) } }, e.track.onmute = function (e) { Janus.log("Remote track muted:", e), a || (a = setTimeout((function () { Janus.log("Removing remote track"); let n = t.pc ? t.pc.getTransceivers() : null, o = n ? n.find((n => n.receiver.track === e.target)) : null, s = o ? o.mid : e.target.id; try { r.onremotetrack(e.target, s, !1, { reason: "mute" }) } catch (e) { Janus.error("Error calling onremotetrack on mute", e) } a = null }), 2520)) }, e.track.onunmute = function (e) { if (Janus.log("Remote track flowing again:", e), null != a) clearTimeout(a), a = null; else try { let n = t.pc ? t.pc.getTransceivers() : null, a = n ? n.find((n => n.receiver.track === e.target)) : null, o = a ? a.mid : e.target.id; r.onremotetrack(e.target, o, !0, { reason: "unmute" }) } catch (e) { Janus.error("Error calling onremotetrack on unmute", e) } } } } async function x(e, n, r) { (r = r || {}).success = "function" == typeof r.success ? r.success : Janus.noop, r.error = "function" == typeof r.error ? r.error : q; let t = r.jsep; if (n && t) return Janus.error("Provided a JSEP to a createOffer"), void r.error("Provided a JSEP to a createOffer"); if (!(n || t && t.type && t.sdp)) return Janus.error("A valid JSEP is required for createAnswer"), void r.error("A valid JSEP is required for createAnswer"); if (r.media && !r.tracks) { if (r.tracks = Janus.mediaToTracks(r.media), !0 === r.simulcast || !0 === r.simulcast2 || r.svc) for (let e of r.tracks) if ("video" === e.type) { !0 === r.simulcast || !0 === r.simulcast2 ? e.simulcast = !0 : r.svc && (e.svc = r.svc); break } Janus.warn("Deprecated media object passed, use tracks instead. Automatically translated to:", r.tracks) } if (r.tracks && !Array.isArray(r.tracks)) return Janus.error("Tracks must be an array"), void r.error("Tracks must be an array"); let a = w.get(e); if (!a || !a.webrtcStuff) return Janus.warn("Invalid handle"), void r.error("Invalid handle"); let o = a.webrtcStuff; var s; o.trickle = (s = r.trickle, Janus.debug("isTrickleEnabled:", s), !1 !== s); try { if (M(e, r), n && await L(e, r), t) { if (await o.pc.setRemoteDescription(t), Janus.log("Remote description accepted!"), o.remoteSdp = t.sdp, o.candidates && o.candidates.length > 0) { for (let e = 0; e < o.candidates.length; e++) { let n = o.candidates[e]; Janus.debug("Adding remote candidate:", n), n && !0 !== n.completed ? o.pc.addIceCandidate(n) : o.pc.addIceCandidate(Janus.endOfCandidates) } o.candidates = [] } await L(e, r); let n = await async function (e, n) { n = n || {}, n.customizeSdp = "function" == typeof n.customizeSdp ? n.customizeSdp : Janus.noop; let r = w.get(e); if (!r || !r.webrtcStuff) throw Janus.warn("Invalid handle"), "Invalid handle"; let t = r.webrtcStuff; Janus.log("Creating answer (iceDone=" + t.iceDone + ")"); let a = await t.pc.createAnswer(); Janus.debug(a); let o = { type: "answer", sdp: a.sdp }; if (n.customizeSdp(o), a.sdp = o.sdp, Janus.log("Setting local description"), t.mySdp = { type: "answer", sdp: a.sdp }, await t.pc.setLocalDescription(a), !t.iceDone && !t.trickle) return Janus.log("Waiting for all candidates..."), null; t.insertableStreams && (a.e2ee = !0); return a }(e, r); r.success(n) } else { let n = await async function (e, n) { n = n || {}, n.customizeSdp = "function" == typeof n.customizeSdp ? n.customizeSdp : Janus.noop; let r = w.get(e); if (!r || !r.webrtcStuff) throw Janus.warn("Invalid handle"), "Invalid handle"; let t = r.webrtcStuff; Janus.log("Creating offer (iceDone=" + t.iceDone + ")"); let a = {}, o = !0 === n.iceRestart; o && (a.iceRestart = !0); Janus.debug(a); let s = await t.pc.createOffer(a); Janus.debug(s); let i = { type: "offer", sdp: s.sdp }; if (n.customizeSdp(i), s.sdp = i.sdp, Janus.log("Setting local description"), t.mySdp = { type: "offer", sdp: s.sdp }, await t.pc.setLocalDescription(s), t.mediaConstraints = a, !t.iceDone && !t.trickle) return Janus.log("Waiting for all candidates..."), null; t.insertableStreams && (s.e2ee = !0); return s }(e, r); r.success(n) } } catch (e) { Janus.error(e), r.error(e) } } function V(e, n) { (n = n || {}).success = "function" == typeof n.success ? n.success : Janus.noop, n.error = "function" == typeof n.error ? n.error : q, n.customizeSdp = "function" == typeof n.customizeSdp ? n.customizeSdp : Janus.noop; let r = n.jsep, t = w.get(e); if (!t || !t.webrtcStuff) return Janus.warn("Invalid handle"), void n.error("Invalid handle"); let a = t.webrtcStuff; if (r) { if (!a.pc) return Janus.warn("Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep"), void n.error("No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep"); n.customizeSdp(r), a.pc.setRemoteDescription(r).then((function () { if (Janus.log("Remote description accepted!"), a.remoteSdp = r.sdp, a.candidates && a.candidates.length > 0) { for (let e = 0; e < a.candidates.length; e++) { let n = a.candidates[e]; Janus.debug("Adding remote candidate:", n), n && !0 !== n.completed ? a.pc.addIceCandidate(n) : a.pc.addIceCandidate(Janus.endOfCandidates) } a.candidates = [] } n.success() }), n.error) } else n.error("Invalid JSEP") } async function N(e, n) { if ((n = n || {}).success = "function" == typeof n.success ? n.success : Janus.noop, n.error = "function" == typeof n.error ? n.error : Janus.noop, n.tracks && !Array.isArray(n.tracks)) return Janus.error("Tracks must be an array"), void n.error("Tracks must be an array"); for (let e of n.tracks) (e.add || !e.replace && !e.remove) && (e.replace = !0); try { await L(e, n), n.success() } catch (e) { Janus.error(e), n.error(e) } } async function L(e, n) { let r = w.get(e); if (!r || !r.webrtcStuff) throw Janus.warn("Invalid handle, not sending anything"), "Invalid handle"; let t = r.webrtcStuff; if (!t.pc) throw Janus.warn("Invalid PeerConnection"), "Invalid PeerConnection"; let a = n.tracks; if (!a || !Array.isArray(a) || 0 === a.length) return; let o = !1, s = {}; for (let e of a) { if (delete e.gumGroup, !e.type || !["audio", "video"].includes(e.type)) continue; if (!e.capture || e.capture instanceof MediaStreamTrack) continue; let n = e.group ? e.group : "default"; s[n] || (s[n] = {}), s[n][e.type] || (e.gumGroup = n, s[n][e.type] = e) } let i = Object.keys(s); for (let e of i) { let n = s[e]; n.audio && n.video || (n.audio && delete n.audio.gumGroup, n.video && delete n.video.gumGroup, delete s[e]) } let c = !!n.jsep; for (let n of a) { if (!n.type) { Janus.warn("Missing track type:", n); continue } if ("data" === n.type) { if (t.pc.ondatachannel) { Janus.warn("Data channel exists already, not creating another one"); continue } Janus.log("Creating default data channel"), P(e, Janus.dataChanDefaultLabel, null, !1), t.pc.ondatachannel = function (n) { Janus.log("Data channel created by Janus:", n), P(e, n.channel.label, n.channel.protocol, n.channel) }; continue } if (void 0 !== n.add && null !== n.add || void 0 !== n.remove && null !== n.remove || void 0 !== n.replace && null !== n.replace || (n.add = !0), n.add && n.remove || n.add && n.remove && n.replace) { Janus.warn("Conflicting actions for track, ignoring:", n); continue } n.add && n.replace ? (Janus.warn("Both add and replace provided, falling back to replace:", n), delete n.add) : n.remove && n.replace && (Janus.warn("Both remove and replace provided, falling back to remove:", n), delete n.replace); let a = n.type; "screen" === n.type && (a = "video"); let i = null, d = null; if (i = n.mid ? t.pc.getTransceivers().find((e => e.mid === n.mid && e.receiver.track.kind === a)) : t.pc.getTransceivers().find((e => e.receiver.track.kind === a)), n.replace || n.remove) { if (!i) { Janus.warn("Couldn't find a transceiver for track:", n); continue } if (!i.sender) { Janus.warn("No sender in the transceiver for track:", n); continue } d = i.sender } if (c && !i && (i = t.pc.getTransceivers().find((e => e.receiver.track.kind === a)), !i)) { Janus.warn("Couldn't find a transceiver for track:", n); continue } let u = null, l = null; if ((n.remove || n.replace) && (Janus.log("Removing track from PeerConnection", n), l = d.track ? d.track.id : null, await d.replaceTrack(null), l && t.myStream)) { let e = null; if ("audio" === a && t.myStream.getAudioTracks() && t.myStream.getAudioTracks().length) for (let n of t.myStream.getAudioTracks()) n.id === l && (e = n, Janus.log("Removing audio track:", e)); else if ("video" === a && t.myStream.getVideoTracks() && t.myStream.getVideoTracks().length) for (let n of t.myStream.getVideoTracks()) n.id === l && (e = n, Janus.log("Removing video track:", e)); if (e) { try { t.myStream.removeTrack(e), r.onlocaltrack(e, !1) } catch (e) { Janus.error("Error calling onlocaltrack on removal for renegotiation", e) } if (!0 !== e.dontStop) try { e.stop() } catch (e) { } } } if (n.capture) { if (n.gumGroup && s[n.gumGroup] && s[n.gumGroup].stream) { let e = s[n.gumGroup].stream; u = "audio" === n.type ? e.getAudioTracks()[0] : e.getVideoTracks()[0], delete s[n.gumGroup].stream, delete s[n.gumGroup], delete n.gumGroup } else if (n.capture instanceof MediaStreamTrack) u = n.capture; else { o || (o = !0, r.consentDialog(!0)); let e = Janus.trackConstraints(n), t = null; if ("audio" === n.type || "video" === n.type) { if (n.gumGroup) { let r = "audio" === n.type ? "video" : "audio"; if (s[n.gumGroup] && s[n.gumGroup][r]) { let t = s[n.gumGroup][r], a = Janus.trackConstraints(t); e[r] = a[r] } } t = await navigator.mediaDevices.getUserMedia(e), n.gumGroup && e.audio && e.video && (s[n.gumGroup].stream = t, delete n.gumGroup) } else t = await navigator.mediaDevices.getDisplayMedia(e); u = "audio" === n.type ? t.getAudioTracks()[0] : t.getVideoTracks()[0] } if (n.replace) { await d.replaceTrack(u); let e = "sendrecv"; !1 !== n.recv && "inactive" !== i.direction && "sendonly" !== i.direction || (e = "sendonly"), i.setDirection ? i.setDirection(e) : i.direction = e } else { if (t.myStream || (t.myStream = new MediaStream), "audio" === a || !n.simulcast && !n.svc) d = t.pc.addTrack(u, t.myStream), i = t.pc.getTransceivers().find((e => e.sender === d)); else if (n.simulcast) { if ("firefox" !== Janus.webRTCAdapter.browserDetails.browser) { Janus.log("Enabling rid-based simulcasting:", u); let e = J(n.simulcastMaxBitrates); i = t.pc.addTransceiver(u, { direction: "sendrecv", streams: [t.myStream], sendEncodings: n.sendEncodings || [{ rid: "h", active: !0, scalabilityMode: "L1T2", maxBitrate: e.high }, { rid: "m", active: !0, scalabilityMode: "L1T2", maxBitrate: e.medium, scaleResolutionDownBy: 2 }, { rid: "l", active: !0, scalabilityMode: "L1T2", maxBitrate: e.low, scaleResolutionDownBy: 4 }] }) } else if (Janus.log("Enabling Simulcasting for Firefox (RID)"), i = t.pc.addTransceiver(u, { direction: "sendrecv", streams: [t.myStream] }), d = i ? i.sender : null, d) { let e = d.getParameters(); e || (e = {}); let r = J(n.simulcastMaxBitrates); e.encodings = n.sendEncodings || [{ rid: "h", active: !0, maxBitrate: r.high }, { rid: "m", active: !0, maxBitrate: r.medium, scaleResolutionDownBy: 2 }, { rid: "l", active: !0, maxBitrate: r.low, scaleResolutionDownBy: 4 }], d.setParameters(e) } } else Janus.log("Enabling SVC (" + n.svc + "):", u), i = t.pc.addTransceiver(u, { direction: "sendrecv", streams: [t.myStream], sendEncodings: [{ scalabilityMode: n.svc }] }); if (d || (d = i ? i.sender : null), n.codec) if ("firefox" === Janus.webRTCAdapter.browserDetails.browser) Janus.warn("setCodecPreferences not supported in Firefox, ignoring codec for track:", n); else if ("string" != typeof n.codec) Janus.warn("Invalid codec value, ignoring for track:", n); else { let e = a + "/" + n.codec.toLowerCase(), r = RTCRtpReceiver.getCapabilities(a).codecs.filter((function (n) { return n.mimeType.toLowerCase() === e })); if (r && 0 !== r.length) { if (i) try { i.setCodecPreferences(r) } catch (e) { Janus.warn("Failed enforcing codec for this " + a + " track:", e) } } else Janus.warn("Codec not supported in this browser for this track, ignoring:", n) } if (n.bitrate) if (n.simulcast || n.svc) Janus.warn("Ignoring bitrate for simulcast/SVC track, use sendEncodings for that"); else if (isNaN(n.bitrate) || n.bitrate < 0) Janus.warn("Ignoring invalid bitrate for track:", n); else if (d) { let e = d.getParameters(); e && e.encodings && 0 !== e.encodings.length ? (e.encodings[0].maxBitrate = n.bitrate, await d.setParameters(e)) : Janus.warn("No encodings in the sender parameters, ignoring bitrate for track:", n) } if ("video" === a && n.framerate) if (n.simulcast || n.svc) Janus.warn("Ignoring framerate for simulcast/SVC track, use sendEncodings for that"); else if (isNaN(n.framerate) || n.framerate < 0) Janus.warn("Ignoring invalid framerate for track:", n); else if (d) { let e = d.getParameters(); e && e.encodings && 0 !== e.encodings.length ? (e.encodings[0].maxFramerate = n.framerate, await d.setParameters(e)) : Janus.warn("No encodings in the sender parameters, ignoring framerate for track:", n) } if (n.transforms) { if (d && n.transforms.sender) { let e = null; RTCRtpSender.prototype.createEncodedStreams ? e = d.createEncodedStreams() : (RTCRtpSender.prototype.createAudioEncodedStreams || RTCRtpSender.prototype.createEncodedVideoStreams) && ("audio" === a ? e = d.createEncodedAudioStreams() : "video" === a && (e = d.createEncodedVideoStreams())), e && (console.log("Insertable Streams sender transform:", e), e.readableStream && e.writableStream ? e.readableStream.pipeThrough(n.transforms.sender).pipeTo(e.writableStream) : e.readable && e.writable && e.readable.pipeThrough(n.transforms.sender).pipeTo(e.writable)) } if (i && i.receiver && n.transforms.receiver) { let e = null; RTCRtpReceiver.prototype.createEncodedStreams ? e = i.receiver.createEncodedStreams() : (RTCRtpReceiver.prototype.createAudioEncodedStreams || RTCRtpReceiver.prototype.createEncodedVideoStreams) && ("audio" === a ? e = i.receiver.createEncodedAudioStreams() : "video" === a && (e = i.receiver.createEncodedVideoStreams())), e && (console.log("Insertable Streams receiver transform:", e), e.readableStream && e.writableStream ? e.readableStream.pipeThrough(n.transforms.receiver).pipeTo(e.writableStream) : e.readable && e.writable && e.readable.pipeThrough(n.transforms.receiver).pipeTo(e.writable)) } } } u && !0 === n.dontStop && (u.dontStop = !0) } else if (n.recv && (i || (i = t.pc.addTransceiver(a)), i)) { if (n.codec) if ("firefox" === Janus.webRTCAdapter.browserDetails.browser) Janus.warn("setCodecPreferences not supported in Firefox, ignoring codec for track:", n); else if ("string" != typeof n.codec) Janus.warn("Invalid codec value, ignoring for track:", n); else { let e = a + "/" + n.codec.toLowerCase(), r = RTCRtpReceiver.getCapabilities(a).codecs.filter((function (n) { return n.mimeType.toLowerCase() === e })); if (r && 0 !== r.length) try { i.setCodecPreferences(r) } catch (e) { Janus.warn("Failed enforcing codec for this " + a + " track:", e) } else Janus.warn("Codec not supported in this browser for this track, ignoring:", n) } if (i.receiver && n.transforms && n.transforms.receiver) { let e = null; RTCRtpReceiver.prototype.createEncodedStreams ? e = i.receiver.createEncodedStreams() : (RTCRtpReceiver.prototype.createAudioEncodedStreams || RTCRtpReceiver.prototype.createEncodedVideoStreams) && ("audio" === a ? e = i.receiver.createEncodedAudioStreams() : "video" === a && (e = i.receiver.createEncodedVideoStreams())), e && (console.log("Insertable Streams receiver transform:", e), e.readableStream && e.writableStream ? e.readableStream.pipeThrough(n.transforms.receiver).pipeTo(e.writableStream) : e.readable && e.writable && e.readable.pipeThrough(n.transforms.receiver).pipeTo(e.writable)) } } if (u) { t.myStream.addTrack(u), u.onended = function (e) { Janus.log("Local track removed:", e); try { r.onlocaltrack(e.target, !1) } catch (e) { Janus.error("Error calling onlocaltrack following end", e) } }; try { r.onlocaltrack(u, !0) } catch (e) { Janus.error("Error calling onlocaltrack for track add", e) } } if (i) { let e = i.direction, r = null, t = u && i.sender.track, a = !1 !== n.recv && i.receiver.track; t && a ? r = "sendrecv" : t && !a ? r = "sendonly" : !t && a ? r = "recvonly" : t || a || (r = "inactive"), r && r !== e && (Janus.warn("Changing direction of transceiver to " + r + " (was " + e + ")", n), i.setDirection ? i.setDirection(r) : i.direction = r) } } o && r.consentDialog(!1) } function G(e) { let n = w.get(e); if (!n || !n.webrtcStuff) return Janus.warn("Invalid handle"), null; let r = n.webrtcStuff; if (!r.pc) return Janus.warn("Invalid PeerConnection"), null; let t = [], a = r.pc.getTransceivers(); for (let e of a) { let n = null; e.sender && e.sender.track && (n = { mid: e.mid }, n.type = e.sender.track.kind, n.id = e.sender.track.id, n.label = e.sender.track.label), n && t.push(n) } return t } function _(e) { let n = w.get(e); if (!n || !n.webrtcStuff) return Janus.warn("Invalid handle"), null; let r = n.webrtcStuff; if (!r.pc) return Janus.warn("Invalid PeerConnection"), null; let t = [], a = r.pc.getTransceivers(); for (let e of a) { let n = null; e.receiver && e.receiver.track && (n = { mid: e.mid }, n.type = e.receiver.track.kind, n.id = e.receiver.track.id, n.label = e.receiver.track.label), n && t.push(n) } return t } function F(e, n, r, t) { t = "function" == typeof t ? t : Janus.noop; let a = w.get(e); if (!a || !a.webrtcStuff) return Janus.warn("Invalid handle"), void t(0); let o = r ? "remote" : "local", s = a.webrtcStuff; if (s.volume[o] || (s.volume[o] = { value: 0 }), s.pc && s.pc.getStats && ("chrome" === Janus.webRTCAdapter.browserDetails.browser || "safari" === Janus.webRTCAdapter.browserDetails.browser)) { let e = s.pc; if (n) { let a = s.pc.getTransceivers().find((e => e.mid === n && "audio" === e.receiver.track.kind)); if (!a) return Janus.warn("No audio transceiver with mid " + n), void t(0); if (r && !a.receiver) return Janus.warn("Remote transceiver track unavailable"), void t(0); if (!r && !a.sender) return Janus.warn("Local transceiver track unavailable"), void t(0); e = r ? a.receiver : a.sender } return e.getStats().then((function (e) { e.forEach((function (e) { e && "audio" === e.kind && (r && !e.remoteSource || !r && "media-source" !== e.type || t(e.audioLevel ? e.audioLevel : 0)) })) })), s.volume[o].value } return Janus.warn("Getting the " + o + " volume unsupported by browser"), void t(0) } function U(e, n, r) { let t = w.get(e); if (!t || !t.webrtcStuff) return Janus.warn("Invalid handle"), !0; let a = t.webrtcStuff; if (!a.pc) return Janus.warn("Invalid PeerConnection"), !0; if (!a.myStream) return Janus.warn("Invalid local MediaStream"), !0; if (r) { if (!a.myStream.getVideoTracks() || 0 === a.myStream.getVideoTracks().length) return Janus.warn("No video track"), !0; if (n) { let e = a.pc.getTransceivers().find((e => e.mid === n && "video" === e.receiver.track.kind)); return e ? e.sender && e.sender.track ? !e.sender.track.enabled : (Janus.warn("No video sender with mid " + n), !0) : (Janus.warn("No video transceiver with mid " + n), !0) } return !a.myStream.getVideoTracks()[0].enabled } if (!a.myStream.getAudioTracks() || 0 === a.myStream.getAudioTracks().length) return Janus.warn("No audio track"), !0; if (n) { let e = a.pc.getTransceivers().find((e => e.mid === n && "audio" === e.receiver.track.kind)); return e ? e.sender && e.sender.track ? !e.sender.track.enabled : (Janus.warn("No audio sender with mid " + n), !0) : (Janus.warn("No audio transceiver with mid " + n), !0) } return !a.myStream.getAudioTracks()[0].enabled } function W(e, n, r, t) { let a = w.get(e); if (!a || !a.webrtcStuff) return Janus.warn("Invalid handle"), !1; let o = a.webrtcStuff; if (!o.pc) return Janus.warn("Invalid PeerConnection"), !1; if (!o.myStream) return Janus.warn("Invalid local MediaStream"), !1; if (r) { if (!o.myStream.getVideoTracks() || 0 === o.myStream.getVideoTracks().length) return Janus.warn("No video track"), !1; if (n) { let e = o.pc.getTransceivers().find((e => e.mid === n && "video" === e.receiver.track.kind)); if (!e) return Janus.warn("No video transceiver with mid " + n), !1; if (!e.sender || !e.sender.track) return Janus.warn("No video sender with mid " + n), !1; e.sender.track.enabled = !t } else for (const e of o.myStream.getVideoTracks()) e.enabled = !t } else { if (!o.myStream.getAudioTracks() || 0 === o.myStream.getAudioTracks().length) return Janus.warn("No audio track"), !1; if (n) { let e = o.pc.getTransceivers().find((e => e.mid === n && "audio" === e.receiver.track.kind)); if (!e) return Janus.warn("No audio transceiver with mid " + n), !1; if (!e.sender || !e.sender.track) return Janus.warn("No audio sender with mid " + n), !1; e.sender.track.enabled = !t } else for (const e of o.myStream.getAudioTracks()) e.enabled = !t } return !0 } function B(e, n) { let r = w.get(e); if (!r || !r.webrtcStuff) return Janus.warn("Invalid handle"), "Invalid handle"; let t = r.webrtcStuff; if (!t.pc) return "Invalid PeerConnection"; if (t.pc.getStats) { let e = t.pc, r = n || "default"; if (n) { let r = t.pc.getTransceivers().find((e => e.mid === n && "video" === e.receiver.track.kind)); if (!r) return Janus.warn("No video transceiver with mid " + n), "No video transceiver with mid " + n; if (!r.receiver) return Janus.warn("No video receiver with mid " + n), "No video receiver with mid " + n; e = r.receiver } return t.bitrate[r] || (t.bitrate[r] = { timer: null, bsnow: null, bsbefore: null, tsnow: null, tsbefore: null, value: "0 kbits/sec" }), t.bitrate[r].timer ? t.bitrate[r].value : (Janus.log("Starting bitrate timer" + (n ? " for mid " + n : "") + " (via getStats)"), t.bitrate[r].timer = setInterval((function () { e.getStats().then((function (e) { e.forEach((function (e) { if (!e) return; let n = !1; if (("video" === e.mediaType || e.id.toLowerCase().indexOf("video") > -1) && "inbound-rtp" === e.type && e.id.indexOf("rtcp") < 0 ? n = !0 : "ssrc" != e.type || !e.bytesReceived || "VP8" !== e.googCodecName && "" !== e.googCodecName || (n = !0), n) if (t.bitrate[r].bsnow = e.bytesReceived, t.bitrate[r].tsnow = e.timestamp, null === t.bitrate[r].bsbefore || null === t.bitrate[r].tsbefore) t.bitrate[r].bsbefore = t.bitrate[r].bsnow, t.bitrate[r].tsbefore = t.bitrate[r].tsnow; else { let e = t.bitrate[r].tsnow - t.bitrate[r].tsbefore; "safari" === Janus.webRTCAdapter.browserDetails.browser && (e /= 1e3); let n = Math.round(8 * (t.bitrate[r].bsnow - t.bitrate[r].bsbefore) / e); "safari" === Janus.webRTCAdapter.browserDetails.browser && (n = parseInt(n / 1e3)), t.bitrate[r].value = n + " kbits/sec", t.bitrate[r].bsbefore = t.bitrate[r].bsnow, t.bitrate[r].tsbefore = t.bitrate[r].tsnow } })) })) }), 1e3), "0 kbits/sec") } return Janus.warn("Getting the video bitrate unsupported by browser"), "Feature unsupported by browser" } function z(e, n, r) { let t = w.get(e); if (!t || !t.webrtcStuff) return void Janus.warn("Invalid handle"); let a = t.webrtcStuff; if (!a.pc) return void Janus.warn("Invalid PeerConnection"); let o = a.pc.getTransceivers().find((e => e.mid === n)); if (!o) return void Janus.warn("No transceiver with mid", n); if (!o.sender) return void Janus.warn("No sender for transceiver with mid", n); let s = o.sender.getParameters(); s && s.encodings && 0 !== s.encodings.length ? s.encodings.length > 1 ? Janus.warn("Ignoring bitrate for simulcast track, use sendEncodings for that") : isNaN(r) || r < 0 ? Janus.warn("Invalid bitrate (must be a positive integer)") : (s.encodings[0].maxBitrate = r, o.sender.setParameters(s)) : Janus.warn("No parameters encodings") } function q(e) { Janus.error("WebRTC error:", e) } function H(e, t) { Janus.log("Cleaning WebRTC stuff"); let a = w.get(e); if (!a) return; let o = a.webrtcStuff; if (o) { if (!0 === t) { let t = { janus: "hangup", transaction: Janus.randomString(12) }; a.token && (t.token = a.token), g && (t.apisecret = g), Janus.debug("Sending hangup request (handle=" + e + "):"), Janus.debug(t), n ? (t.session_id = b, t.handle_id = e, r.send(JSON.stringify(t))) : Janus.httpAPICall(i + "/" + b + "/" + e, { verb: "POST", withCredentials: l, body: t }) } o.volume && (o.volume.local && o.volume.local.timer && clearInterval(o.volume.local.timer), o.volume.remote && o.volume.remote.timer && clearInterval(o.volume.remote.timer)); for (let e in o.bitrate) o.bitrate[e].timer && clearInterval(o.bitrate[e].timer); o.bitrate = {}, !o.streamExternal && o.myStream && (Janus.log("Stopping local stream tracks"), Janus.stopAllTracks(o.myStream)), o.streamExternal = !1, o.myStream = null; try { o.pc.close() } catch (e) { } o.pc = null, o.candidates = null, o.mySdp = null, o.remoteSdp = null, o.iceDone = !1, o.dataChannel = {}, o.dtmfSender = null, o.insertableStreams = !1 } a.oncleanup() } R(e), this.getServer = function () { return i }, this.isConnected = function () { return h }, this.reconnect = function (e) { (e = e || {}).success = "function" == typeof e.success ? e.success : Janus.noop, e.error = "function" == typeof e.error ? e.error : Janus.noop, e.reconnect = !0, R(e) }, this.getSessionId = function () { return b }, this.getInfo = function (e) { !function (e) { if (e = e || {}, e.success = "function" == typeof e.success ? e.success : Janus.noop, e.error = "function" == typeof e.error ? e.error : Janus.noop, Janus.log("Getting info on Janus instance"), !h) return Janus.warn("Is the server down? (connected=false)"), void e.error("Is the server down? (connected=false)"); let t = Janus.randomString(12), a = { janus: "info", transaction: t }; p && (a.token = p); g && (a.apisecret = g); if (n) return k.set(t, (function (n) { Janus.log("Server info:"), Janus.debug(n), "server_info" !== n.janus && Janus.error("Ooops: " + n.error.code + " " + n.error.reason), e.success(n) })), void r.send(JSON.stringify(a)); Janus.httpAPICall(i, { verb: "POST", withCredentials: l, body: a, success: function (n) { Janus.log("Server info:"), Janus.debug(n), "server_info" !== n.janus && Janus.error("Ooops: " + n.error.code + " " + n.error.reason), e.success(n) }, error: function (n, r) { Janus.error(n + ":", r), "" === r ? e.error(n + ": Is the server down?") : e.error(n + ": " + r) } }) }(e) }, this.destroy = function (o) { !function (o) { o = o || {}, o.success = "function" == typeof o.success ? o.success : Janus.noop, o.error = "function" == typeof o.error ? o.error : Janus.noop; let s = !0 === o.unload, c = !0; void 0 !== o.notifyDestroyed && null !== o.notifyDestroyed && (c = !0 === o.notifyDestroyed); let d = !0 === o.cleanupHandles; if (Janus.log("Destroying session " + b + " (unload=" + s + ")"), !b) return Janus.warn("No session to destroy"), o.success(), void (c && e.destroyed()); if (d) for (const e of w.keys()) j(e, { noRequest: !0 }); if (!h) return Janus.warn("Is the server down? (connected=false)"), b = null, void o.success(); let u = { janus: "destroy", transaction: Janus.randomString(12) }; p && (u.token = p); g && (u.apisecret = g); if (s) return n ? (r.onclose = null, r.close(), r = null) : navigator.sendBeacon(i + "/" + b, JSON.stringify(u)), Janus.log("Destroyed session:"), b = null, h = !1, o.success(), void (c && e.destroyed()); if (n) { u.session_id = b; let n = function () { for (let e in t) r.removeEventListener(e, t[e]); r.removeEventListener("message", s), r.removeEventListener("error", i), a && clearTimeout(a), r.close() }, s = function (r) { let t = JSON.parse(r.data); t.session_id == u.session_id && t.transaction == u.transaction && (n(), o.success(), c && e.destroyed()) }, i = function () { n(), o.error("Failed to destroy the server: Is the server down?"), c && e.destroyed() }; return r.addEventListener("message", s), r.addEventListener("error", i), void (1 === r.readyState ? r.send(JSON.stringify(u)) : i()) } Janus.httpAPICall(i + "/" + b, { verb: "POST", withCredentials: l, body: u, success: function (n) { Janus.log("Destroyed session:"), Janus.debug(n), b = null, h = !1, "success" !== n.janus && Janus.error("Ooops: " + n.error.code + " " + n.error.reason), o.success(), c && e.destroyed() }, error: function (n, r) { Janus.error(n + ":", r), b = null, h = !1, o.success(), c && e.destroyed() } }) }(o) }, this.attach = function (e) { !function (e) { if (e = e || {}, e.success = "function" == typeof e.success ? e.success : Janus.noop, e.error = "function" == typeof e.error ? e.error : Janus.noop, e.dataChannelOptions = e.dataChannelOptions || { ordered: !0 }, e.consentDialog = "function" == typeof e.consentDialog ? e.consentDialog : Janus.noop, e.iceState = "function" == typeof e.iceState ? e.iceState : Janus.noop, e.mediaState = "function" == typeof e.mediaState ? e.mediaState : Janus.noop, e.webrtcState = "function" == typeof e.webrtcState ? e.webrtcState : Janus.noop, e.slowLink = "function" == typeof e.slowLink ? e.slowLink : Janus.noop, e.onmessage = "function" == typeof e.onmessage ? e.onmessage : Janus.noop, e.onlocaltrack = "function" == typeof e.onlocaltrack ? e.onlocaltrack : Janus.noop, e.onremotetrack = "function" == typeof e.onremotetrack ? e.onremotetrack : Janus.noop, e.ondata = "function" == typeof e.ondata ? e.ondata : Janus.noop, e.ondataopen = "function" == typeof e.ondataopen ? e.ondataopen : Janus.noop, e.oncleanup = "function" == typeof e.oncleanup ? e.oncleanup : Janus.noop, e.ondetached = "function" == typeof e.ondetached ? e.ondetached : Janus.noop, !h) return Janus.warn("Is the server down? (connected=false)"), void e.error("Is the server down? (connected=false)"); let t = e.plugin; if (!t) return Janus.error("Invalid plugin"), void e.error("Invalid plugin"); let a = e.opaqueId, o = e.loopIndex, s = e.token ? e.token : p, c = Janus.randomString(12), d = { janus: "attach", plugin: t, opaque_id: a, loop_index: o, transaction: c }; s && (d.token = s); g && (d.apisecret = g); if (n) return k.set(c, (function (n) { if (Janus.debug(n), "success" !== n.janus) return Janus.error("Ooops: " + n.error.code + " " + n.error.reason), void e.error("Ooops: " + n.error.code + " " + n.error.reason); let r = n.data.id; Janus.log("Created handle: " + r); let a = { session: y, plugin: t, id: r, token: s, detached: !1, webrtcStuff: { started: !1, myStream: null, streamExternal: !1, mySdp: null, mediaConstraints: null, pc: null, dataChannelOptions: e.dataChannelOptions, dataChannel: {}, dtmfSender: null, trickle: !0, iceDone: !1, bitrate: {} }, getId: function () { return r }, getPlugin: function () { return t }, getVolume: function (e, n) { return F(r, e, !0, n) }, getRemoteVolume: function (e, n) { return F(r, e, !0, n) }, getLocalVolume: function (e, n) { return F(r, e, !1, n) }, isAudioMuted: function (e) { return U(r, e, !1) }, muteAudio: function (e) { return W(r, e, !1, !0) }, unmuteAudio: function (e) { return W(r, e, !1, !1) }, isVideoMuted: function (e) { return U(r, e, !0) }, muteVideo: function (e) { return W(r, e, !0, !0) }, unmuteVideo: function (e) { return W(r, e, !0, !1) }, getBitrate: function (e) { return B(r, e) }, setMaxBitrate: function (e, n) { return z(r, e, n) }, send: function (e) { A(r, e) }, data: function (e) { E(r, e) }, dtmf: function (e) { O(r, e) }, consentDialog: e.consentDialog, iceState: e.iceState, mediaState: e.mediaState, webrtcState: e.webrtcState, slowLink: e.slowLink, onmessage: e.onmessage, createOffer: function (e) { x(r, !0, e) }, createAnswer: function (e) { x(r, !1, e) }, handleRemoteJsep: function (e) { V(r, e) }, replaceTracks: function (e) { N(r, e) }, getLocalTracks: function () { return G(r) }, getRemoteTracks: function () { return _(r) }, onlocaltrack: e.onlocaltrack, onremotetrack: e.onremotetrack, ondata: e.ondata, ondataopen: e.ondataopen, oncleanup: e.oncleanup, ondetached: e.ondetached, hangup: function (e) { H(r, !0 === e) }, detach: function (e) { j(r, e) } }; w.set(r, a), e.success(a) })), d.session_id = b, void r.send(JSON.stringify(d)); Janus.httpAPICall(i + "/" + b, { verb: "POST", withCredentials: l, body: d, success: function (n) { if (Janus.debug(n), "success" !== n.janus) return Janus.error("Ooops: " + n.error.code + " " + n.error.reason), void e.error("Ooops: " + n.error.code + " " + n.error.reason); let r = n.data.id; Janus.log("Created handle: " + r); let a = { session: y, plugin: t, id: r, token: s, detached: !1, webrtcStuff: { started: !1, myStream: null, streamExternal: !1, mySdp: null, mediaConstraints: null, pc: null, dataChannelOptions: e.dataChannelOptions, dataChannel: {}, dtmfSender: null, trickle: !0, iceDone: !1, bitrate: {} }, getId: function () { return r }, getPlugin: function () { return t }, getVolume: function (e, n) { return F(r, e, !0, n) }, getRemoteVolume: function (e, n) { return F(r, e, !0, n) }, getLocalVolume: function (e, n) { return F(r, e, !1, n) }, isAudioMuted: function (e) { return U(r, e, !1) }, muteAudio: function (e) { return W(r, e, !1, !0) }, unmuteAudio: function (e) { return W(r, e, !1, !1) }, isVideoMuted: function (e) { return U(r, e, !0) }, muteVideo: function (e) { return W(r, e, !0, !0) }, unmuteVideo: function (e) { return W(r, e, !0, !1) }, getBitrate: function (e) { return B(r, e) }, setMaxBitrate: function (e, n) { return z(r, e, n) }, send: function (e) { A(r, e) }, data: function (e) { E(r, e) }, dtmf: function (e) { O(r, e) }, consentDialog: e.consentDialog, iceState: e.iceState, mediaState: e.mediaState, webrtcState: e.webrtcState, slowLink: e.slowLink, onmessage: e.onmessage, createOffer: function (e) { x(r, !0, e) }, createAnswer: function (e) { x(r, !1, e) }, handleRemoteJsep: function (e) { V(r, e) }, replaceTracks: function (e) { N(r, e) }, getLocalTracks: function () { return G(r) }, getRemoteTracks: function () { return _(r) }, onlocaltrack: e.onlocaltrack, onremotetrack: e.onremotetrack, ondata: e.ondata, ondataopen: e.ondataopen, oncleanup: e.oncleanup, ondetached: e.ondetached, hangup: function (e) { H(r, !0 === e) }, detach: function (e) { j(r, e) } }; w.set(r, a), e.success(a) }, error: function (n, r) { Janus.error(n + ":", r), "" === r ? e.error(n + ": Is the server down?") : e.error(n + ": " + r) } }) }(e) } } Janus.useDefaultDependencies = function (e) { let n = e && e.fetch || fetch, r = e && e.Promise || Promise, t = e && e.WebSocket || WebSocket; return { newWebSocket: function (e, n) { return new t(e, n) }, extension: e && e.extension || defaultExtension, isArray: function (e) { return Array.isArray(e) }, webRTCAdapter: e && e.adapter || adapter, httpAPICall: function (e, t) { let a = { method: t.verb, headers: { Accept: "application/json, text/plain, */*" }, cache: "no-cache" }; "POST" === t.verb && (a.headers["Content-Type"] = "application/json"), void 0 !== t.withCredentials && (a.credentials = !0 === t.withCredentials ? "include" : t.withCredentials ? t.withCredentials : "omit"), t.body && (a.body = JSON.stringify(t.body)); let o = n(e, a).catch((function (e) { return r.reject({ message: "Probably a network error, is the server down?", error: e }) })); if (t.timeout) { let e = new r((function (e, n) { let r = setTimeout((function () { return clearTimeout(r), n({ message: "Request timed out", timeout: t.timeout }) }), t.timeout) })); o = r.race([o, e]) } return o.then((function (e) { return e.ok ? typeof t.success == typeof Janus.noop ? e.json().then((function (e) { try { t.success(e) } catch (e) { Janus.error("Unhandled httpAPICall success callback error", e) } }), (function (n) { return r.reject({ message: "Failed to parse response body", error: n, response: e }) })) : void 0 : r.reject({ message: "API call failed", response: e }) })).catch((function (e) { typeof t.error == typeof Janus.noop && t.error(e.message || "<< internal error >>", e) })), o } } }, Janus.useOldDependencies = function (e) { let n = e && e.jQuery || jQuery, r = e && e.WebSocket || WebSocket; return { newWebSocket: function (e, n) { return new r(e, n) }, isArray: function (e) { return n.isArray(e) }, extension: e && e.extension || defaultExtension, webRTCAdapter: e && e.adapter || adapter, httpAPICall: function (e, r) { let t = void 0 !== r.body ? { contentType: "application/json", data: JSON.stringify(r.body) } : {}, a = void 0 !== r.withCredentials ? { xhrFields: { withCredentials: r.withCredentials } } : {}; return n.ajax(n.extend(t, a, { url: e, type: r.verb, cache: !1, dataType: "json", async: r.async, timeout: r.timeout, success: function (e) { typeof r.success == typeof Janus.noop && r.success(e) }, error: function (e, n, t) { typeof r.error == typeof Janus.noop && r.error(n, t) } })) } } }, Janus.mediaToTracks = function (e) { let n = []; if (e) { if (!e.keepAudio && !1 !== e.audio && (void 0 === e.audio || e.audio || e.audioSend || e.audioRecv || e.addAudio || e.replaceAudio || e.removeAudio)) { let r = { type: "audio" }; e.removeAudio ? r.remove = !0 : (e.addAudio ? r.add = !0 : e.replaceAudio && (r.replace = !0), !1 !== e.audioSend && (r.capture = e.audio || !0), !1 !== e.audioRecv && (r.recv = !0)), (r.remove || r.capture || r.recv) && n.push(r) } if (!e.keepVideo && !1 !== e.video && (void 0 === e.video || e.video || e.videoSend || e.videoRecv || e.addVideo || e.replaceVideo || e.removeVideo)) { let r = { type: "video" }; e.removeVideo ? r.remove = !0 : (e.addVideo ? r.add = !0 : e.replaceVideo && (r.replace = !0), !1 !== e.videoSend && (r.capture = e.video || !0, ["screen", "window", "desktop"].includes(r.capture) && (r.type = "screen", r.capture = { video: {} }, e.screenshareFrameRate && (r.capture.frameRate = e.screenshareFrameRate), e.screenshareHeight && (r.capture.height = e.screenshareHeight), e.screenshareWidth && (r.capture.width = e.screenshareWidth))), !1 !== e.videoRecv && (r.recv = !0)), (r.remove || r.capture || r.recv) && n.push(r) } e.data && n.push({ type: "data" }) } else n.push({ type: "audio", capture: !0, recv: !0 }), n.push({ type: "video", capture: !0, recv: !0 }); return n }, Janus.trackConstraints = function (e) { let n = {}; if (!e || !e.capture) return n; if ("audio" === e.type) n.audio = e.capture; else if ("video" === e.type) if ((e.simulcast || e.svc) && !0 === e.capture && (e.capture = "hires"), !0 === e.capture || "object" == typeof e.capture) n.video = e.capture; else { let r = 0, t = 0; "lowres" === e.capture ? (r = 320, t = 240) : "lowres-16:9" === e.capture ? (r = 320, t = 180) : "hires" === e.capture || "hires-16:9" === e.capture || "hdres" === e.capture ? (r = 1280, t = 720) : "fhdres" === e.capture ? (r = 1920, t = 1080) : "4kres" === e.capture ? (r = 3840, t = 2160) : "stdres" === e.capture ? (r = 640, t = 480) : "stdres-16:9" === e.capture ? (r = 640, t = 360) : (Janus.log("Default video setting is stdres 4:3"), r = 640, t = 480), n.video = { width: { ideal: r }, height: { ideal: t } } } else "screen" === e.type && (n.video = e.capture); return n }, Janus.noop = function () { }, Janus.dataChanDefaultLabel = "JanusDataChannel", Janus.endOfCandidates = null, Janus.stopAllTracks = function (e) { try { let n = e.getTracks(); for (let e of n) Janus.log(e), e && !0 !== e.dontStop && e.stop() } catch (e) { } }, Janus.init = function (e) { if ((e = e || {}).callback = "function" == typeof e.callback ? e.callback : Janus.noop, Janus.initDone) e.callback(); else { if (void 0 === console.log && (console.log = function () { }), Janus.trace = Janus.noop, Janus.debug = Janus.noop, Janus.vdebug = Janus.noop, Janus.log = Janus.noop, Janus.warn = Janus.noop, Janus.error = Janus.noop, !0 === e.debug || "all" === e.debug) Janus.trace = console.trace.bind(console), Janus.debug = console.debug.bind(console), Janus.vdebug = console.debug.bind(console), Janus.log = console.log.bind(console), Janus.warn = console.warn.bind(console), Janus.error = console.error.bind(console); else if (Array.isArray(e.debug)) for (let n of e.debug) switch (n) { case "trace": Janus.trace = console.trace.bind(console); break; case "debug": Janus.debug = console.debug.bind(console); break; case "vdebug": Janus.vdebug = console.debug.bind(console); break; case "log": Janus.log = console.log.bind(console); break; case "warn": Janus.warn = console.warn.bind(console); break; case "error": Janus.error = console.error.bind(console); break; default: console.error("Unknown debugging option '" + n + "' (supported: 'trace', 'debug', 'vdebug', 'log', warn', 'error')") }Janus.log("Initializing library"); let n = e.dependencies || Janus.useDefaultDependencies(); Janus.isArray = n.isArray, Janus.webRTCAdapter = n.webRTCAdapter, Janus.httpAPICall = n.httpAPICall, Janus.newWebSocket = n.newWebSocket, Janus.extension = n.extension, Janus.extension.init(), Janus.listDevices = function (e, n) { e = "function" == typeof e ? e : Janus.noop, n || (n = { audio: !0, video: !0 }), Janus.isGetUserMediaAvailable() ? navigator.mediaDevices.getUserMedia(n).then((function (n) { navigator.mediaDevices.enumerateDevices().then((function (r) { Janus.debug(r), e(r), Janus.stopAllTracks(n) })) })).catch((function (n) { Janus.error(n), e([]) })) : (Janus.warn("navigator.mediaDevices unavailable"), e([])) }, Janus.attachMediaStream = function (e, n) { try { e.srcObject = n } catch (r) { try { e.src = URL.createObjectURL(n) } catch (e) { Janus.error("Error attaching stream to element", e) } } }, Janus.reattachMediaStream = function (e, n) { try { e.srcObject = n.srcObject } catch (r) { try { e.src = n.src } catch (e) { Janus.error("Error reattaching stream to element", e) } } }; let r = ["iPad", "iPhone", "iPod"].indexOf(navigator.platform) >= 0 ? "pagehide" : "beforeunload", t = window["on" + r]; if (window.addEventListener(r, (function () { Janus.log("Closing window"); for (const [e, n] of Janus.sessions) n && n.destroyOnUnload && (Janus.log("Destroying session " + e), n.destroy({ unload: !0, notifyDestroyed: !1 })); t && "function" == typeof t && t() })), Janus.safariVp8 = !1, Janus.safariVp9 = !1, "safari" === Janus.webRTCAdapter.browserDetails.browser && Janus.webRTCAdapter.browserDetails.version >= 605) if (RTCRtpSender && RTCRtpSender.getCapabilities && RTCRtpSender.getCapabilities("video") && RTCRtpSender.getCapabilities("video").codecs && RTCRtpSender.getCapabilities("video").codecs.length) { for (let e of RTCRtpSender.getCapabilities("video").codecs) e && e.mimeType && "video/vp8" === e.mimeType.toLowerCase() ? Janus.safariVp8 = !0 : e && e.mimeType && "video/vp9" === e.mimeType.toLowerCase() && (Janus.safariVp9 = !0); Janus.safariVp8 ? Janus.log("This version of Safari supports VP8") : Janus.warn("This version of Safari does NOT support VP8: if you're using a Technology Preview, try enabling the 'WebRTC VP8 codec' setting in the 'Experimental Features' Develop menu") } else { let e = new RTCPeerConnection({}); e.createOffer({ offerToReceiveVideo: !0 }).then((function (n) { Janus.safariVp8 = -1 !== n.sdp.indexOf("VP8"), Janus.safariVp9 = -1 !== n.sdp.indexOf("VP9"), Janus.safariVp8 ? Janus.log("This version of Safari supports VP8") : Janus.warn("This version of Safari does NOT support VP8: if you're using a Technology Preview, try enabling the 'WebRTC VP8 codec' setting in the 'Experimental Features' Develop menu"), e.close(), e = null })) } Janus.initDone = !0, e.callback() } }, Janus.isWebrtcSupported = function () { return !!window.RTCPeerConnection }, Janus.isGetUserMediaAvailable = function () { return navigator.mediaDevices && navigator.mediaDevices.getUserMedia }, Janus.randomString = function (e) { let n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = ""; for (let t = 0; t < e; t++) { let e = Math.floor(62 * Math.random()); r += n.charAt(e) } return r };
